<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Matrix — TREVSHADOW</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; }
    #err{
      position:fixed; inset:0; padding:16px;
      font:14px/1.4 monospace; color:#fff; background:#000;
      white-space:pre-wrap; display:none;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="err"></div>

<script>
(() => {
  const errBox = document.getElementById("err");
  const showErr = (e) => {
    errBox.style.display = "block";
    errBox.textContent = "Matrix crashed:\n\n" + (e && e.stack ? e.stack : String(e));
  };

  try {
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha:false });

    // =========================
    // LOCKED “GOOD” VIBE DIALS
    // =========================
    const FONT_SIZE = 16;
    const FADE = 0.10;               // clean trails, no blocky buildup
    const BASE_SPEED = 0.10;
    const SPEED_JITTER = 0.16;
    const DENSITY_PASSES = 1;        // keep crisp

    // ONLY the two upgrades you wanted:
    const JITTER_PX = 0.40;          // subtle organic drift
    const DEPTH_MIN_ALPHA = 0.50;    // far background
    const DEPTH_MAX_ALPHA = 1.00;    // foreground

    // Heads (mostly green, tiny rainbow)
    const RAINBOW_HEAD_CHANCE = 0.18;
    const SPARKLE_CHANCE = 0.03;

    // LIGHT ceiling “crumbles” (not a heavy curtain)
    const CEILING_ROWS = 6;
    const CRUMBLE_RATE = 0.016;

    // Startup: “Matrix-built” word then falls apart
    const START_TEXT = "TREVSHADOW";
    const TYPE_MS_PER_CHAR = 80;
    const HOLD_AFTER_TYPE_MS = 500;
    const DISSOLVE_MS = 1400;

    const BODY_GREEN = "#00ff66";
    const HEAD_MINT  = "#9dffcf";

    const CHARS =
      "アイウエオカキクケコサシスセソタチツテトナニヌネノ" +
      "ハヒフヘホマミムメモヤユヨラリルレロワ" +
      "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
      "!@#$%^&*()_+-=[]{};:,.<>/?";

    const randChar = () => CHARS[(Math.random()*CHARS.length)|0];

    let columns = 0, drops = [], speeds = [];
    let hueBase = 0;

    // Light ceiling layer + crumbs
    let ceilGrid = [];
    let frags = []; // {x,y,ch,vy,life}

    function setup() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width  = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.imageSmoothingEnabled = false;

      columns = Math.max(1, Math.floor(window.innerWidth / FONT_SIZE));

      drops  = new Array(columns);
      speeds = new Array(columns);

      for (let i=0; i<columns; i++) {
        drops[i] = Math.random() * (window.innerHeight / FONT_SIZE);
        speeds[i] = BASE_SPEED + Math.random() * SPEED_JITTER;
      }

      ceilGrid = new Array(CEILING_ROWS);
      for (let r=0; r<CEILING_ROWS; r++) {
        ceilGrid[r] = new Array(columns);
        for (let c=0; c<columns; c++) ceilGrid[r][c] = randChar();
      }

      frags = [];

      ctx.font = `${FONT_SIZE}px monospace`;
      ctx.textBaseline = "top";
      ctx.textAlign = "left";

      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,window.innerWidth,window.innerHeight);
    }

    function headColor(i, y) {
      if (Math.random() < SPARKLE_CHANCE) return "#fff";
      if (Math.random() < RAINBOW_HEAD_CHANCE) {
        const hue = (hueBase + i*13 + y*0.10) % 360;
        return `hsl(${hue},90%,65%)`;
      }
      return HEAD_MINT;
    }

    function updateCrumble() {
      // spawn a few crumbs from the top rows only
      for (let c=0; c<columns; c++) {
        if (Math.random() < CRUMBLE_RATE) {
          const r = (Math.random() * CEILING_ROWS) | 0;
          const ch = ceilGrid[r][c];
          ceilGrid[r][c] = randChar();
          frags.push({
            x: c * FONT_SIZE,
            y: r * FONT_SIZE,
            ch,
            vy: (BASE_SPEED + Math.random()*0.8) * FONT_SIZE * 1.8,
            life: 1.0
          });
        }
      }

      const H = window.innerHeight;
      for (let i=frags.length-1; i>=0; i--) {
        const f = frags[i];
        f.y += f.vy;
        f.life *= 0.988;
        if (f.y > H + 60 || f.life < 0.08) frags.splice(i, 1);
      }
    }

    function drawCeiling() {
      // Keep it light and not “blocky”
      for (let r=0; r<CEILING_ROWS; r++) {
        for (let c=0; c<columns; c++) {
          const x = c * FONT_SIZE;
          const y = r * FONT_SIZE;
          ctx.globalAlpha = 0.25 + (1 - r/CEILING_ROWS) * 0.25; // subtle
          ctx.fillStyle = BODY_GREEN;
          ctx.fillText(ceilGrid[r][c], x, y);
        }
      }

      // Falling crumbs
      for (const f of frags) {
        ctx.globalAlpha = Math.min(1, f.life);
        ctx.fillStyle = headColor((f.x / FONT_SIZE) | 0, f.y);
        ctx.fillText(f.ch, f.x, f.y);
      }

      ctx.globalAlpha = 1;
    }

    // Startup word as “glyph-built”: rendered as many tiny glyphs forming letters
    const t0 = performance.now();

    // offscreen mask for the startup word
    const mask = document.createElement("canvas");
    const mctx = mask.getContext("2d");

    function buildWordMask() {
      mask.width = window.innerWidth;
      mask.height = window.innerHeight;
      mctx.clearRect(0,0,mask.width,mask.height);

      const size = Math.max(44, Math.min(110, Math.floor(window.innerWidth / 10)));
      const cx = mask.width/2;
      const cy = Math.max(CEILING_ROWS*FONT_SIZE + 90, mask.height*0.30);

      mctx.fillStyle = "#000";
      mctx.fillRect(0,0,mask.width,mask.height);

      mctx.textAlign = "center";
      mctx.textBaseline = "middle";
      mctx.font = `900 ${size}px monospace`;
      mctx.fillStyle = "#fff";
      mctx.fillText(START_TEXT, cx, cy);

      return { size, cx, cy };
    }

    let maskMeta = null;

    function drawStartup(elapsed) {
      if (!maskMeta) maskMeta = buildWordMask();

      const typedCount = Math.min(START_TEXT.length, Math.floor(elapsed / TYPE_MS_PER_CHAR));
      const typeDoneAt = START_TEXT.length * TYPE_MS_PER_CHAR;
      const holdEndsAt = typeDoneAt + HOLD_AFTER_TYPE_MS;
      const dissolveEndsAt = holdEndsAt + DISSOLVE_MS;

      const { size, cx, cy } = maskMeta;

      // typing: only reveal part of the word by drawing a clipped mask width
      const revealFrac = Math.min(1, typedCount / START_TEXT.length);

      const img = mctx.getImageData(0,0,mask.width,mask.height).data;

      // Sample points inside the letter mask and place glyphs there
      // (This makes it feel like the word is made of code, not a solid title)
      const left = cx - (size * START_TEXT.length * 0.30);
      const right = cx + (size * START_TEXT.length * 0.30);
      const clipRight = left + (right - left) * revealFrac;

      let dissolveT = 0;
      if (elapsed > holdEndsAt) dissolveT = Math.min(1, (elapsed - holdEndsAt) / DISSOLVE_MS);

      // fewer points while typing; more points when fully visible
      const points = (revealFrac < 1) ? 650 : 950;

      for (let k=0; k<points; k++) {
        const x = left + Math.random() * (clipRight - left);
        const y = (cy - size*0.6) + Math.random() * (size*1.2);
        const xi = x | 0, yi = y | 0;
        if (xi < 0 || yi < 0 || xi >= mask.width || yi >= mask.height) continue;

        const idx = (yi * mask.width + xi) * 4;
        if (img[idx] > 10) {
          // inside the word shape
          const a = 0.65 * (1 - dissolveT);
          ctx.globalAlpha = a;

          // subtle rainbow shimmer on some of the “word-glyphs”
          ctx.fillStyle = (Math.random() < 0.18)
            ? headColor(((x/FONT_SIZE)|0), y)
            : BODY_GREEN;

          ctx.fillText(randChar(), x, y);

          // dissolve: spawn falling crumbs from the word area
          if (elapsed > holdEndsAt && Math.random() < 0.08) {
            frags.push({
              x: ((x / FONT_SIZE)|0) * FONT_SIZE,
              y,
              ch: randChar(),
              vy: (BASE_SPEED + Math.random()*1.2) * FONT_SIZE * 1.9,
              life: 1.0
            });
          }
        }
      }

      ctx.globalAlpha = 1;

      return elapsed < dissolveEndsAt;
    }

    function drawRain() {
      for (let pass=0; pass<DENSITY_PASSES; pass++) {
        for (let i=0; i<columns; i++) {
          const x = i * FONT_SIZE;
          const y = drops[i] * FONT_SIZE;

          // depth fade (2)
          const depth = Math.min(1, Math.max(0, y / window.innerHeight));
          ctx.globalAlpha = DEPTH_MIN_ALPHA + depth * (DEPTH_MAX_ALPHA - DEPTH_MIN_ALPHA);

          // jitter (1)
          const jitter = (Math.random() - 0.5) * JITTER_PX;

          // body
          ctx.fillStyle = BODY_GREEN;
          ctx.fillText(randChar(), x + jitter, y);

          // head highlight with tiny glow (crisp, not blocky)
          const headY = y - FONT_SIZE * 2;
          if (headY >= 0 && headY < window.innerHeight) {
            const col = headColor(i, headY);
            ctx.fillStyle = col;
            ctx.shadowColor = col;
            ctx.shadowBlur = 4;
            ctx.fillText(randChar(), x + jitter, headY);
            ctx.shadowBlur = 0;
          }

          drops[i] += speeds[i];

          if (y > window.innerHeight && Math.random() > 0.975) {
            drops[i] = 0;
            speeds[i] = BASE_SPEED + Math.random() * SPEED_JITTER;
          }
        }
      }

      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    function frame(t) {
      const elapsed = t - t0;
      hueBase = (hueBase + 1) % 360;

      // clean fade
      ctx.fillStyle = `rgba(0,0,0,${FADE})`;
      ctx.fillRect(0,0,window.innerWidth,window.innerHeight);

      updateCrumble();
      drawCeiling();
      drawRain();
      drawStartup(elapsed);

      requestAnimationFrame(frame);
    }

    window.addEventListener("resize", () => {
      maskMeta = null;
      setup();
    });
    window.addEventListener("error", (ev) => showErr(ev.error || ev.message));

    setup();
    requestAnimationFrame(frame);

  } catch (e) {
    showErr(e);
  }
})();
</script>
</body>
</html>
