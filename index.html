<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Matrix Terminal — TREVSHADOW</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  /* ===================== DIALS ===================== */
  const CELL = 16;
  const FPS_MS = 88;
  const TRAIL_ALPHA = 0.16;

  const MAX_WORDS = 90;
  const SPAWN_RATE = 0.55;
  const WORD_ROWS_SPREAD = 8;

  const SLOW_TOP_FRAC = 0.33;
  const TOP_MULT = 0.18;
  const MID_MULT = 0.55;

  const BOTTOM_FADE_FRAC = 0.12;

  const DRIFT_X = 0.12;
  const DRIFT_X_JITTER = 0.10;

  const GLYPH_SPARK_RATE = 0.22;
  const GLYPH_SPARK_COUNT = 2;

  const START_TEXT = "TREVSHADOW";
  const TYPE_MS_PER_CHAR = 90;
  const HOLD_AFTER_TYPE_MS = 650;
  const FALL_GAP_MS = 140;
  const FALL_DURATION_MS = 1100;

  /* ===================== COLORS ===================== */
  const BODY_DARK  = "#0b6b2a";
  const BODY_MID   = "#00b84a";
  const BODY_GREEN = "#00ff66";
  const HEAD_COLORS = ["#00ff66", "#00ffd5", "#ff4dff", "#ffe14d", "#ffffff"];
  const headColor = () => HEAD_COLORS[(Math.random() * HEAD_COLORS.length) | 0];

  /* ===================== TEXT POOLS ===================== */
  const MATRIX_CHARS =
    "ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜ" +
    "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
    "!@#$%^&*()_+-=[]{};:,.<>/?";

  const CODE_TOKENS = [
    "const","let","function","return",
    "tick()","resize()","Math.random()",
    "ctx.fillRect","canvas","CELL","FPS_MS",
    "TREVSHADOW",">.<"
  ];

  const CODE_TEXT = `
const CELL=16,FPS_MS=88;
function tick(){ return; }
// TREVSHADOW >.<
`;
  const CODE_GLYPHS = Array.from(new Set(
    CODE_TEXT.replace(/\s+/g," ").split("").filter(ch => ch !== "\n")
  )).join("");

  const randFrom = s => s[(Math.random() * s.length) | 0];
  const randChar = () => randFrom(MATRIX_CHARS);
  const randGlyph = () => (Math.random() < 0.3 ? randFrom(CODE_GLYPHS) : randChar());
  const randToken = () => CODE_TOKENS[(Math.random() * CODE_TOKENS.length) | 0];

  /* ===================== DPR SAFE ===================== */
  let dpr = 1, cssW = 0, cssH = 0, W = 0, H = 0;

  function resize() {
    dpr = Math.max(1, devicePixelRatio || 1);
    canvas.width = innerWidth * dpr;
    canvas.height = innerHeight * dpr;
    cssW = canvas.width / dpr;
    cssH = canvas.height / dpr;

    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.imageSmoothingEnabled = false;
    ctx.font = `${CELL}px monospace`;
    ctx.textBaseline = "top";

    W = Math.floor(cssW / CELL);
    H = Math.floor(cssH / CELL);

    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,cssW,cssH);
  }

  /* ===================== ✨ CLEAN 3D DRAW CELL ✨ ===================== */
  function drawCell(x, y, ch, color, alpha=1) {
    if (x < 0 || x >= W || y < 0 || y >= H || alpha <= 0) return;

    const p = y / Math.max(1, H - 1);
    const depth = p * p;

    const parallax = (depth - 0.5) * 0.18;
    const px = (x + parallax) * CELL;
    const py = y * CELL;

    const prev = ctx.globalAlpha;

    // soft depth shadow (single pass — no rectangles)
    ctx.globalAlpha = alpha * 0.22;
    ctx.fillStyle = "#00180a";
    ctx.fillText(ch, px + 1, py + 1);

    // main glyph
    ctx.globalAlpha = alpha * (0.55 + depth * 0.45);
    ctx.fillStyle = color;
    ctx.fillText(ch, px, py);

    ctx.globalAlpha = prev;
  }

  /* ===================== SPEED CURVES ===================== */
  function speedMultiplierForY(y) {
    const p = y / Math.max(1, H - 1);
    if (p <= SLOW_TOP_FRAC) return TOP_MULT;
    const t = (p - SLOW_TOP_FRAC) / (1 - SLOW_TOP_FRAC);
    return TOP_MULT + (MID_MULT - TOP_MULT) * (t * t);
  }

  function bottomFadeAlpha(y) {
    const p = y / Math.max(1, H - 1);
    const s = 1 - BOTTOM_FADE_FRAC;
    return p <= s ? 1 : Math.max(0, 1 - (p - s) / BOTTOM_FADE_FRAC);
  }

  /* ===================== WORDS ===================== */
  const words = [];

  function spawnWord() {
    if (words.length >= MAX_WORDS) return;
    const token = randToken();
    words.push({
      x: Math.random() * (W - token.length),
      y: -1 - Math.random() * WORD_ROWS_SPREAD,
      vx: (Math.random()*2-1)*DRIFT_X,
      vy: 0.55 + Math.random()*0.35,
      token,
      colHead: headColor(),
      colBody: BODY_GREEN
    });
  }

  /* ===================== LOOP ===================== */
  let last = performance.now(), acc = 0;

  function loop(now) {
    acc += Math.min(now - last, 200);
    last = now;

    while (acc >= FPS_MS) {
      tick();
      acc -= FPS_MS;
    }
    requestAnimationFrame(loop);
  }

  function tick() {
    ctx.fillStyle = `rgba(0,0,0,${TRAIL_ALPHA})`;
    ctx.fillRect(0,0,cssW,cssH);

    if (Math.random() < SPAWN_RATE) spawnWord();

    for (let i = words.length - 1; i >= 0; i--) {
      const w = words[i];
      w.y += w.vy * speedMultiplierForY(w.y);
      w.x += w.vx;

      for (let c = 0; c < w.token.length; c++) {
        drawCell(w.x + c, w.y, 
          Math.random() < 0.1 ? randGlyph() : w.token[c],
          c === 0 ? w.colHead : w.colBody,
          bottomFadeAlpha(w.y)
        );
      }

      if (w.y > H + 4) words.splice(i,1);
    }
  }

  addEventListener("resize", resize);
  resize();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
