<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Matrix Terminal — TREVSHADOW</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; }
    #err{
      position:fixed; inset:0; padding:14px;
      font:14px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      color:#fff; background:#000; display:none; white-space:pre-wrap;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="err"></div>

<script>
(() => {
  const errBox = document.getElementById("err");
  const showErr = (e) => {
    errBox.style.display = "block";
    errBox.textContent = "Matrix crashed:\n\n" + (e && e.stack ? e.stack : String(e));
  };
  window.addEventListener("error", (ev) => showErr(ev.error || ev.message));
  window.addEventListener("unhandledrejection", (ev) => showErr(ev.reason || ev));

  try {
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha: false });

    // ===== "POWERSHELL LOOK" DIALS =====
    const CELL = 16;
    const FPS_MS = 88;            // overall a bit slower than before (was 77)

    // Top "layer" of letters (always present)
    const CEILING_ROWS = 3;
    const TRANSITION_ROWS = 7;
    const CRUMBLE_RATE = 0.020;
    const FRAG_MAX = 1700;

    // Rain behavior (continuous)
    const RAIN_PASSES = 3;

    // integer speeds (safe)
    const SPEED_MIN = 1;
    const SPEED_MAX = 3;

    const TRAIL_ALPHA = 0.05;

    // Tall, continuous columns
    const TAIL_MIN = 18;
    const TAIL_MAX_FRAC = 0.98;

    // Living tail (keeps changing)
    const TAIL_LIVE_CELLS = 26;
    const TAIL_SPREAD_STEP = 1;

    // Startup word (plays ONCE, then never again)
    const START_TEXT = "TREVSHADOW";
    const TYPE_MS_PER_CHAR = 90;
    const HOLD_AFTER_TYPE_MS = 650;
    const FALL_GAP_MS = 140;
    const FALL_DURATION_MS = 1100;

    // Speed curve + fade-out
    const SLOW_TOP_FRAC = 0.33;       // top third = much slower
    const TOP_MULT = 0.22;            // slower than base at top
    const MID_MULT = 0.55;            // still slower than before overall
    const BOTTOM_FADE_FRAC = 0.10;    // last 10% fades out

    // Code-glimpse layer (very subtle)
    const CODE_WHISPER_RATE = 0.09;   // higher = more code glimpses
    const CODE_WHISPER_ALPHA = 0.16;  // how visible the code text is
    const CODE_WHISPER_ROWS = 12;     // how far down code whispers can appear

    // Rare >.< stamps
    const EMOTE_RATE = 0.006;         // chance per tick to place a >.< somewhere

    // Colors
    const BODY_DARK  = "#0b6b2a";
    const BODY_MID   = "#00b84a";
    const BODY_GREEN = "#00ff66";
    const HEAD_COLORS = ["#00ff66", "#00ffd5", "#ff4dff", "#ffe14d", "#ffffff"];

    // Main charset (katakana + alnum + symbols)
    const CHARS = (
      "ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜ" +
      "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
      "!@#$%^&*()_+-=[]{};:,.<>/?"
    );

    // --- The “code it’s made of” (short excerpts, shuffled into the rain) ---
    // Keep it short-ish so it’s not huge, but recognizable.
    const CODE_TEXT = `
const CELL=16,FPS_MS=88,CEILING_ROWS=3,TRANSITION_ROWS=7;
function tick(elapsedMs){
  ctx.fillStyle=\`rgba(0,0,0,\${TRAIL_ALPHA})\`;
  ctx.fillRect(0,0,window.innerWidth,window.innerHeight);
}
function speedMultiplierForY(y){
  const p=y/Math.max(1,(H-1));
  if(p<=SLOW_TOP_FRAC) return TOP_MULT;
  const t=(p-SLOW_TOP_FRAC)/Math.max(0.0001,(1-SLOW_TOP_FRAC));
  return TOP_MULT+(MID_MULT-TOP_MULT)*(t*t);
}
function bottomFadeAlpha(y){
  const p=y/Math.max(1,(H-1));
  const start=1.0-BOTTOM_FADE_FRAC;
  if(p<=start) return 1;
  const t=(p-start)/Math.max(0.0001,BOTTOM_FADE_FRAC);
  return Math.max(0,1-t);
}
// TREVSHADOW >.<
`;

    // Build a glyph pool from CODE_TEXT (plus a few spicy extras)
    const CODE_GLYPHS = Array.from(
      new Set(
        CODE_TEXT
          .replace(/\s+/g, " ")
          .split("")
          .filter(ch => ch !== "\n" && ch !== "\r")
      )
    ).join("");

    const randFrom = (s) => s[(Math.random() * s.length) | 0];

    // Mix: mostly Matrix chars, sometimes code glyphs
    function randGlyph() {
      // ~22% chance to draw a character from the code-glyph pool
      if (Math.random() < 0.22) return randFrom(CODE_GLYPHS);
      return randFrom(CHARS);
    }

    const headColor = () => (Math.random() < 0.70 ? HEAD_COLORS[0] : HEAD_COLORS[(Math.random() * HEAD_COLORS.length) | 0]);

    // Grid size in cells
    let W = 0, H = 0;
    let drops = [];
    let speed = [];
    let len = [];
    let ceiling = [];
    let frags = [];
    let frame = 0;
    let dropAcc = []; // per-column fractional movement accumulator

    // Startup timing (once)
    const t0 = performance.now();
    const typeDoneAt = START_TEXT.length * TYPE_MS_PER_CHAR;
    const holdEndsAt = typeDoneAt + HOLD_AFTER_TYPE_MS;
    const startupTotal =
      holdEndsAt + (START_TEXT.length - 1) * FALL_GAP_MS + FALL_DURATION_MS;
    let startupDone = false;

    function resize() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.imageSmoothingEnabled = false;

      W = Math.max(20, Math.floor(window.innerWidth / CELL));
      H = Math.max(12, Math.floor(window.innerHeight / CELL));

      drops = new Array(W);
      speed = new Array(W);
      len   = new Array(W);
      dropAcc = new Array(W);

      for (let x = 0; x < W; x++) {
        drops[x] = (Math.random() * H) | 0;
        speed[x] = SPEED_MIN + ((Math.random() * (SPEED_MAX - SPEED_MIN + 1)) | 0);
        len[x]   = Math.max(TAIL_MIN, ((Math.random() * (H * TAIL_MAX_FRAC)) | 0));
        dropAcc[x] = 0;
      }

      ceiling = new Array(CEILING_ROWS);
      for (let r = 0; r < CEILING_ROWS; r++) {
        ceiling[r] = new Array(W);
        for (let x = 0; x < W; x++) ceiling[r][x] = randGlyph();
      }

      frags = [];
      frame = 0;

      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
      ctx.font = `${CELL}px monospace`;
      ctx.textBaseline = "top";
    }

    function addFrag(x, y, ch, v, col) {
      if (frags.length >= FRAG_MAX) return;
      frags.push({ x, y, ch, v, col, life: 1.0 });
    }

    function drawCell(x, y, ch, color, alpha = 1) {
      if (x < 0 || x >= W || y < 0 || y >= H) return;
      if (alpha <= 0) return;
      const prev = ctx.globalAlpha;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.fillText(ch, x * CELL, y * CELL);
      ctx.globalAlpha = prev;
    }

    function drawTextCentered(text, row, color) {
      const startX = Math.max(0, ((W - text.length) / 2) | 0);
      for (let i = 0; i < text.length; i++) drawCell(startX + i, row, text[i], color, 1);
      return startX;
    }

    // Safe fixed-step loop (prevents mobile spiral)
    let last = performance.now();
    let acc = 0;
    const MAX_TICKS_PER_FRAME = 6;

    function loop(now) {
      const dt = now - last;
      last = now;

      acc += Math.min(dt, 200);

      let ticks = 0;
      while (acc >= FPS_MS && ticks < MAX_TICKS_PER_FRAME) {
        tick(now - t0);
        acc -= FPS_MS;
        ticks++;
      }
      if (ticks >= MAX_TICKS_PER_FRAME) acc = 0;

      requestAnimationFrame(loop);
    }

    function ceilingAlphaForRow(r) {
      const startFade = Math.max(0, CEILING_ROWS - TRANSITION_ROWS);
      if (r < startFade) return 1;
      const t = (CEILING_ROWS - r) / Math.max(1, TRANSITION_ROWS);
      return Math.max(0.10, Math.min(1, t));
    }

    function rainAlphaForY(y) {
      if (y >= CEILING_ROWS) return 1;
      const t = (y + 1) / Math.max(1, TRANSITION_ROWS);
      return Math.max(0.0, Math.min(0.85, t));
    }

    function speedMultiplierForY(y) {
      const p = y / Math.max(1, (H - 1)); // 0..1
      if (p <= SLOW_TOP_FRAC) return TOP_MULT;
      const t = (p - SLOW_TOP_FRAC) / Math.max(0.0001, (1 - SLOW_TOP_FRAC));
      const eased = t * t; // gentle ease-in
      return TOP_MULT + (MID_MULT - TOP_MULT) * eased; // never exceeds MID_MULT
    }

    function bottomFadeAlpha(y) {
      const p = y / Math.max(1, (H - 1)); // 0..1
      const start = 1.0 - BOTTOM_FADE_FRAC;
      if (p <= start) return 1;
      const t = (p - start) / Math.max(0.0001, BOTTOM_FADE_FRAC);
      return Math.max(0, 1 - t);
    }

    function stampEmote() {
      // Place >.< as 3 cells so it renders correctly
      const y = (Math.random() * Math.min(H - 2, Math.max(6, Math.floor(H * 0.60)))) | 0;
      const x = (Math.random() * (W - 3)) | 0;
      const a = 0.45 * bottomFadeAlpha(y);
      drawCell(x + 0, y, ">", "#ffffff", a);
      drawCell(x + 1, y, ".", "#ff4dff", a);
      drawCell(x + 2, y, "<", "#ffffff", a);
    }

    function codeWhisper() {
      // Faint scattered “code” glimpses behind everything (not constant)
      if (Math.random() > CODE_WHISPER_RATE) return;
      const y = (Math.random() * Math.min(H - 1, CODE_WHISPER_ROWS)) | 0;
      const startX = (Math.random() * Math.max(1, W - 20)) | 0;
      const run = 10 + ((Math.random() * 18) | 0);

      // sample a slice from CODE_TEXT so you get readable-ish fragments
      const clean = CODE_TEXT.replace(/\s+/g, " ");
      const idx = (Math.random() * Math.max(1, clean.length - run - 1)) | 0;
      const slice = clean.slice(idx, idx + run);

      for (let i = 0; i < slice.length && (startX + i) < W; i++) {
        const ch = slice[i];
        // keep it subtle and “behind”
        drawCell(startX + i, y, ch, BODY_DARK, CODE_WHISPER_ALPHA * ceilingAlphaForRow(Math.min(y, CEILING_ROWS - 1)));
      }
    }

    function tick(elapsedMs) {
      ctx.fillStyle = `rgba(0,0,0,${TRAIL_ALPHA})`;
      ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

      // subtle code glimpses in the background
      codeWhisper();

      // occasional >.<
      if (Math.random() < EMOTE_RATE) stampEmote();

      // 1) ceiling crumble
      for (let x = 0; x < W; x++) {
        if (Math.random() < CRUMBLE_RATE) {
          const r = (Math.random() * CEILING_ROWS) | 0;
          const ch = ceiling[r][x];
          ceiling[r][x] = randGlyph();
          addFrag(x, r, ch, 0.6 + Math.random() * 1.2, headColor());
        }
      }

      // ceiling draw (blended)
      for (let r = 0; r < CEILING_ROWS; r++) {
        const a = ceilingAlphaForRow(r);
        const col = (r <= 1) ? "#ffffff" : (r <= 3) ? BODY_GREEN : BODY_DARK;
        for (let x = 0; x < W; x++) drawCell(x, r, ceiling[r][x], col, a);
      }

      // fragments
      for (let i = frags.length - 1; i >= 0; i--) {
        const f = frags[i];
        f.y += f.v;
        f.life *= 0.985;
        const yy = (f.y | 0);
        const a = Math.min(1, f.life) * (yy < CEILING_ROWS ? 0.75 : 1) * bottomFadeAlpha(yy);
        drawCell(f.x, yy, f.ch, f.col, a);
        if (f.y > H + 2 || f.life < 0.08) frags.splice(i, 1);
      }

      // 3) continuous rain (wrap) with slow-top curve + bottom fade
      for (let pass = 0; pass < RAIN_PASSES; pass++) {
        for (let x = 0; x < W; x++) {
          if ((frame % speed[x]) !== 0) continue;

          const yHead = drops[x];

          // living tail (now uses randGlyph so the “code” shows up in the rain)
          const tailDraw = Math.min(len[x], TAIL_LIVE_CELLS);
          for (let t = 0; t < tailDraw; t += TAIL_SPREAD_STEP) {
            const yy = yHead - t;
            if (yy < 0 || yy >= H) continue;

            let col = BODY_DARK;
            if (t === 0) col = headColor();
            else if (t <= 2) col = BODY_GREEN;
            else if (t <= 7) col = BODY_MID;

            const a = rainAlphaForY(yy) * bottomFadeAlpha(yy);
            drawCell(x, yy, randGlyph(), col, a);
          }

          if (yHead >= 0 && yHead < H && Math.random() < 0.08) {
            const a = rainAlphaForY(yHead) * bottomFadeAlpha(yHead);
            drawCell(x, yHead, randGlyph(), "#ffffff", a);
          }

          // move: MUCH slower at top, gently faster mid, never "tons faster"
          dropAcc[x] += speedMultiplierForY(yHead);
          if (dropAcc[x] >= 1) {
            const steps = Math.min(3, dropAcc[x] | 0);
            drops[x] += steps;
            dropAcc[x] -= steps;
          }

          if (drops[x] > H + len[x]) {
            drops[x] = 0;
            dropAcc[x] = 0;
          }
        }
      }

      // 4) Startup once
      if (!startupDone) {
        if (elapsedMs < startupTotal) {
          const wordRow = Math.min(H - 2, CEILING_ROWS + 2);

          const typedCount = Math.min(START_TEXT.length, (elapsedMs / TYPE_MS_PER_CHAR) | 0);
          const typed = START_TEXT.slice(0, typedCount);
          const baseX = drawTextCentered(typed, wordRow, BODY_GREEN);

          if (elapsedMs > holdEndsAt) {
            for (let i = 0; i < START_TEXT.length; i++) {
              const letterStart = holdEndsAt + i * FALL_GAP_MS;
              const t = (elapsedMs - letterStart) / FALL_DURATION_MS;

              if (t >= 0 && t <= 1) {
                const x = baseX + i;
                const useLetter = (Math.random() < 0.60);
                const ch = useLetter ? START_TEXT[i] : randGlyph();
                addFrag(x, wordRow, ch, 0.9 + Math.random() * 1.7, useLetter ? "#ffffff" : headColor());
              }
            }
          }
        } else {
          startupDone = true;
        }
      }

      frame++;
    }

    window.addEventListener("resize", resize);
    resize();
    requestAnimationFrame(loop);

  } catch (e) {
    showErr(e);
  }
})();
</script>
</body>
</html>
