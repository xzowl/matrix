<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Matrix Terminal — TREVSHADOW</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; }
    #err{
      position:fixed; inset:0; padding:14px;
      font:14px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      color:#fff; background:#000; display:none; white-space:pre-wrap;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="err"></div>

<script>
(() => {
  const errBox = document.getElementById("err");
  const showErr = (e) => {
    errBox.style.display = "block";
    errBox.textContent = "Matrix crashed:\n\n" + (e && e.stack ? e.stack : String(e));
  };
  window.addEventListener("error", (ev) => showErr(ev.error || ev.message));
  window.addEventListener("unhandledrejection", (ev) => showErr(ev.reason || ev));

  try {
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha: false });

    // ===== LOOK / SPEED =====
    const CELL = 16;
    const FPS_MS = 88;              // overall slightly slower than earlier

    // Ceiling
    const CEILING_ROWS = 3;
    const TRANSITION_ROWS = 7;
    const CRUMBLE_RATE = 0.020;
    const FRAG_MAX = 1600;

    // Rain
    const RAIN_PASSES = 3;
    const SPEED_MIN = 1;
    const SPEED_MAX = 3;
    const TRAIL_ALPHA = 0.05;

    const TAIL_MIN = 18;
    const TAIL_MAX_FRAC = 0.98;

    // Living tail
    const TAIL_LIVE_CELLS = 26;
    const TAIL_SPREAD_STEP = 1;     // if a phone struggles: set to 2

    // Startup text
    const START_TEXT = "TREVSHADOW";
    const TYPE_MS_PER_CHAR = 90;
    const HOLD_AFTER_TYPE_MS = 650;
    const FALL_GAP_MS = 140;
    const FALL_DURATION_MS = 1100;

    // Slow top + bottom fade
    const SLOW_TOP_FRAC = 0.33;     // top third much slower
    const TOP_MULT = 0.18;          // VERY slow at top
    const MID_MULT = 0.52;          // still slower than “normal”
    const BOTTOM_FADE_FRAC = 0.10;  // last 10% fades out

    // Readable code whispers (cell-by-cell; NOT blocky)
    const CODE_WHISPER_RATE = 0.07;     // chance per tick to place a token trail
    const CODE_WHISPER_ALPHA = 0.18;    // subtle
    const CODE_WHISPER_ROWS = 14;       // mostly in upper area

    // Rare >.< stamps
    const EMOTE_RATE = 0.006;

    // Colors
    const BODY_DARK  = "#0b6b2a";
    const BODY_MID   = "#00b84a";
    const BODY_GREEN = "#00ff66";
    const HEAD_COLORS = ["#00ff66", "#00ffd5", "#ff4dff", "#ffe14d", "#ffffff"];

    const MATRIX_CHARS = (
      "ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜ" +
      "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
      "!@#$%^&*()_+-=[]{};:,.<>/?"
    );

    // The readable tokens you wanted
    const CODE_TOKENS = [
      "const","function","return","tick()","resize()",
      "speedMultiplierForY","bottomFadeAlpha",
      "Math.random()","requestAnimationFrame",
      "ctx.fillRect","canvas","CELL","FPS_MS",
      "TREVSHADOW",">.<"
    ];

    // A small code glyph pool (for “self-made-of-code” vibe)
    const CODE_TEXT = `
const CELL=16,FPS_MS=88;
function tick(){ return; }
function speedMultiplierForY(y){ return y; }
function bottomFadeAlpha(y){ return y; }
// TREVSHADOW >.<
`;
    const CODE_GLYPHS = Array.from(new Set(
      CODE_TEXT.replace(/\s+/g," ").split("").filter(ch => ch !== "\n" && ch !== "\r")
    )).join("");

    const randFrom = (s) => s[(Math.random() * s.length) | 0];
    const randChar = () => randFrom(MATRIX_CHARS);
    const randGlyph = () => (Math.random() < 0.22 ? randFrom(CODE_GLYPHS) : randChar());
    const headColor = () => (Math.random() < 0.70 ? HEAD_COLORS[0] : HEAD_COLORS[(Math.random() * HEAD_COLORS.length) | 0]);
    const randToken = () => CODE_TOKENS[(Math.random() * CODE_TOKENS.length) | 0];

    // Grid size
    let W = 0, H = 0, dpr = 1;
    let cssW = 0, cssH = 0;

    // State
    let drops = [];
    let speed = [];
    let len   = [];
    let dropAcc = [];
    let ceiling = [];
    let frags = [];
    let frame = 0;

    // Startup timing (once)
    const t0 = performance.now();
    const typeDoneAt = START_TEXT.length * TYPE_MS_PER_CHAR;
    const holdEndsAt = typeDoneAt + HOLD_AFTER_TYPE_MS;
    const startupTotal =
      holdEndsAt + (START_TEXT.length - 1) * FALL_GAP_MS + FALL_DURATION_MS;
    let startupDone = false;

    function resize() {
      dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width  = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);

      cssW = canvas.width / dpr;
      cssH = canvas.height / dpr;

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.imageSmoothingEnabled = false;

      W = Math.max(20, Math.floor(cssW / CELL));
      H = Math.max(12, Math.floor(cssH / CELL));

      drops = new Array(W);
      speed = new Array(W);
      len   = new Array(W);
      dropAcc = new Array(W);

      for (let x = 0; x < W; x++) {
        drops[x] = (Math.random() * H) | 0;
        speed[x] = SPEED_MIN + ((Math.random() * (SPEED_MAX - SPEED_MIN + 1)) | 0);
        len[x]   = Math.max(TAIL_MIN, ((Math.random() * (H * TAIL_MAX_FRAC)) | 0));
        dropAcc[x] = 0;
      }

      ceiling = new Array(CEILING_ROWS);
      for (let r = 0; r < CEILING_ROWS; r++) {
        ceiling[r] = new Array(W);
        for (let x = 0; x < W; x++) ceiling[r][x] = randGlyph();
      }

      frags = [];
      frame = 0;

      ctx.font = `${CELL}px monospace`;
      ctx.textBaseline = "top";

      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, cssW, cssH);
    }

    function addFrag(x, y, ch, v, col) {
      if (frags.length >= FRAG_MAX) return;
      frags.push({ x, y, ch, v, col, life: 1.0 });
    }

    function drawCell(x, y, ch, color, alpha = 1) {
      if (x < 0 || x >= W || y < 0 || y >= H) return;
      if (alpha <= 0) return;
      const prev = ctx.globalAlpha;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.fillText(ch, x * CELL, y * CELL);
      ctx.globalAlpha = prev;
    }

    function drawTextCentered(text, row, color) {
      const startX = Math.max(0, ((W - text.length) / 2) | 0);
      for (let i = 0; i < text.length; i++) drawCell(startX + i, row, text[i], color, 1);
      return startX;
    }

    function ceilingAlphaForRow(r) {
      const startFade = Math.max(0, CEILING_ROWS - TRANSITION_ROWS);
      if (r < startFade) return 1;
      const t = (CEILING_ROWS - r) / Math.max(1, TRANSITION_ROWS);
      return Math.max(0.10, Math.min(1, t));
    }

    function rainAlphaForY(y) {
      if (y >= CEILING_ROWS) return 1;
      const t = (y + 1) / Math.max(1, TRANSITION_ROWS);
      return Math.max(0.0, Math.min(0.85, t));
    }

    function speedMultiplierForY(y) {
      const p = y / Math.max(1, (H - 1)); // 0..1
      if (p <= SLOW_TOP_FRAC) return TOP_MULT;
      const t = (p - SLOW_TOP_FRAC) / Math.max(0.0001, (1 - SLOW_TOP_FRAC));
      const eased = t * t;
      return TOP_MULT + (MID_MULT - TOP_MULT) * eased; // never exceeds MID_MULT
    }

    function bottomFadeAlpha(y) {
      const p = y / Math.max(1, (H - 1)); // 0..1
      const start = 1.0 - BOTTOM_FADE_FRAC;
      if (p <= start) return 1;
      const t = (p - start) / Math.max(0.0001, BOTTOM_FADE_FRAC);
      return Math.max(0, 1 - t);
    }

    function stampEmote() {
      // >.< as 3 cells (looks clean)
      const y = (Math.random() * Math.min(H - 2, Math.max(6, Math.floor(H * 0.60)))) | 0;
      const x = (Math.random() * (W - 3)) | 0;
      const a = 0.45 * bottomFadeAlpha(y);
      drawCell(x + 0, y, ">", "#ffffff", a);
      drawCell(x + 1, y, ".", "#ff4dff", a);
      drawCell(x + 2, y, "<", "#ffffff", a);
    }

    // Readable code whispers without blockiness:
    // Place token characters into grid cells with gaps/jitter so it “leaks” rather than forms a slab.
    function codeWhisper() {
      if (Math.random() > CODE_WHISPER_RATE) return;

      const token = randToken();
      const y = (Math.random() * Math.min(H - 1, CODE_WHISPER_ROWS)) | 0;
      let x = (Math.random() * Math.max(1, W - token.length - 2)) | 0;

      // Randomly choose horizontal or slight diagonal drift
      const slope = (Math.random() < 0.5) ? 0 : (Math.random() < 0.5 ? 1 : -1);

      for (let i = 0; i < token.length; i++) {
        // Gaps keep it from looking like a rectangle/solid bar
        if (Math.random() < 0.18) { x++; continue; }

        const yy = y + ((slope !== 0 && Math.random() < 0.55) ? (slope * ((i / 3) | 0)) : 0);
        const a =
          CODE_WHISPER_ALPHA *
          (yy < CEILING_ROWS ? ceilingAlphaForRow(yy | 0) : 1) *
          bottomFadeAlpha(yy);

        // Use dark green so it’s “behind”
        drawCell(x, yy, token[i], BODY_DARK, a);
        x++;

        if (x >= W) break;
      }
    }

    // Safe fixed-step loop (prevents mobile spiral)
    let last = performance.now();
    let accTime = 0;
    const MAX_TICKS_PER_FRAME = 6;

    function loop(now) {
      const dt = now - last;
      last = now;

      accTime += Math.min(dt, 200);

      let ticks = 0;
      while (accTime >= FPS_MS && ticks < MAX_TICKS_PER_FRAME) {
        tick(now - t0);
        accTime -= FPS_MS;
        ticks++;
      }
      if (ticks >= MAX_TICKS_PER_FRAME) accTime = 0;

      requestAnimationFrame(loop);
    }

    function tick(elapsedMs) {
      // Fade using CSS pixel size (prevents rectangles / DPR weirdness)
      ctx.fillStyle = `rgba(0,0,0,${TRAIL_ALPHA})`;
      ctx.fillRect(0, 0, cssW, cssH);

      // Background readable code whispers
      codeWhisper();

      // occasional >.<
      if (Math.random() < EMOTE_RATE) stampEmote();

      // 1) ceiling crumble
      for (let x = 0; x < W; x++) {
        if (Math.random() < CRUMBLE_RATE) {
          const r = (Math.random() * CEILING_ROWS) | 0;
          const ch = ceiling[r][x];
          ceiling[r][x] = randGlyph();
          addFrag(x, r, ch, 0.6 + Math.random() * 1.2, headColor());
        }
      }

      // draw ceiling (blended)
      for (let r = 0; r < CEILING_ROWS; r++) {
        const a = ceilingAlphaForRow(r);
        const col = (r <= 1) ? "#ffffff" : (r <= 2) ? BODY_GREEN : BODY_DARK;
        for (let x = 0; x < W; x++) drawCell(x, r, ceiling[r][x], col, a);
      }

      // fragments
      for (let i = frags.length - 1; i >= 0; i--) {
        const f = frags[i];
        f.y += f.v;
        f.life *= 0.985;

        const yy = (f.y | 0);
        const a = Math.min(1, f.life) * (yy < CEILING_ROWS ? 0.75 : 1) * bottomFadeAlpha(yy);
        drawCell(f.x, yy, f.ch, f.col, a);

        if (f.y > H + 2 || f.life < 0.08) frags.splice(i, 1);
      }

      // 3) continuous rain with slow-top curve + bottom fade
      for (let pass = 0; pass < RAIN_PASSES; pass++) {
        for (let x = 0; x < W; x++) {
          if ((frame % speed[x]) !== 0) continue;

          const yHead = drops[x];

          const tailDraw = Math.min(len[x], TAIL_LIVE_CELLS);
          for (let t = 0; t < tailDraw; t += TAIL_SPREAD_STEP) {
            const yy = yHead - t;
            if (yy < 0 || yy >= H) continue;

            let col = BODY_DARK;
            if (t === 0) col = headColor();
            else if (t <= 2) col = BODY_GREEN;
            else if (t <= 7) col = BODY_MID;

            const a = rainAlphaForY(yy) * bottomFadeAlpha(yy);
            drawCell(x, yy, randGlyph(), col, a);
          }

          if (yHead >= 0 && yHead < H && Math.random() < 0.08) {
            const a = rainAlphaForY(yHead) * bottomFadeAlpha(yHead);
            drawCell(x, yHead, randGlyph(), "#ffffff", a);
          }

          // movement (top very slow, mid gently faster but still overall slow)
          dropAcc[x] += speedMultiplierForY(yHead);
          if (dropAcc[x] >= 1) {
            const steps = Math.min(3, dropAcc[x] | 0);
            drops[x] += steps;
            dropAcc[x] -= steps;
          }

          if (drops[x] > H + len[x]) {
            drops[x] = 0;
            dropAcc[x] = 0;
          }
        }
      }

      // 4) Startup: TREVSHADOW types in, holds, then falls away one letter at a time
      if (!startupDone) {
        if (elapsedMs < startupTotal) {
          const wordRow = Math.min(H - 2, CEILING_ROWS + 2);

          const typedCount = Math.min(START_TEXT.length, (elapsedMs / TYPE_MS_PER_CHAR) | 0);
          const typed = START_TEXT.slice(0, typedCount);
          const baseX = drawTextCentered(typed, wordRow, BODY_GREEN);

          if (elapsedMs > holdEndsAt) {
            for (let i = 0; i < START_TEXT.length; i++) {
              const letterStart = holdEndsAt + i * FALL_GAP_MS;
              const t = (elapsedMs - letterStart) / FALL_DURATION_MS;

              if (t >= 0 && t <= 1) {
                const xx = baseX + i;

                // Falling-away letter: sometimes itself, sometimes flips to glyph
                const useLetter = (Math.random() < 0.65);
                const ch = useLetter ? START_TEXT[i] : randGlyph();
                addFrag(xx, wordRow, ch, 0.9 + Math.random() * 1.7, useLetter ? "#ffffff" : headColor());

                // Encourage streams beneath the letters
                if (xx >= 0 && xx < W) {
                  drops[xx] = Math.min(drops[xx], wordRow + 1);
                  speed[xx] = Math.min(speed[xx], 3);
                  len[xx] = Math.max(len[xx], Math.floor(H * 0.75));
                }
              }
            }
          }
        } else {
          startupDone = true;
        }
      }

      frame++;
    }

    window.addEventListener("resize", resize);
    resize();
    requestAnimationFrame(loop);

  } catch (e) {
    showErr(e);
  }
})();
</script>
</body>
</html>
