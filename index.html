<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Matrix Terminal — TREVSHADOW</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  // ===== "POWERSHELL LOOK" DIALS =====
  const CELL = 16;              // grid cell size
  const FPS_MS = 55;            // higher = slower

  // Top "layer" of letters (always present)
  const CEILING_ROWS = 10;
  const CRUMBLE_RATE = 0.020;
  const FRAG_MAX = 1600;

  // Rain behavior (continuous)
  const RAIN_PASSES = 3;
  const SPEED_MIN = 1;
  const SPEED_MAX = 4;
  const TRAIL_ALPHA = 0.05;     // trails without freezing

  // Tall, continuous columns
  const TAIL_MIN = 18;
  const TAIL_MAX_FRAC = 0.98;

  // Living tail (keeps changing)
  const TAIL_LIVE_CELLS = 26;
  const TAIL_SPREAD_STEP = 1;   // 1 best look

  // Startup word (plays ONCE, then never again)
  const START_TEXT = "TREVSHADOW";
  const TYPE_MS_PER_CHAR = 90;
  const HOLD_AFTER_TYPE_MS = 650;
  const FALL_GAP_MS = 140;
  const FALL_DURATION_MS = 1100;

  // Colors
  const BODY_DARK  = "#0b6b2a";
  const BODY_MID   = "#00b84a";
  const BODY_GREEN = "#00ff66";
  const HEAD_COLORS = ["#00ff66", "#00ffd5", "#ff4dff", "#ffe14d", "#ffffff"];

  const CHARS = (
    "ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜ" +
    "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
    "!@#$%^&*()_+-=[]{};:,.<>/?"
  );

  const randChar = () => CHARS[(Math.random() * CHARS.length) | 0];
  const headColor = () => (Math.random() < 0.70 ? HEAD_COLORS[0] : HEAD_COLORS[(Math.random() * HEAD_COLORS.length) | 0]);

  // Grid size in cells
  let W = 0, H = 0;
  let drops = [];
  let speed = [];
  let len = [];
  let ceiling = [];
  let frags = [];
  let frame = 0;

  // Startup timing (once)
  const t0 = performance.now();
  const typeDoneAt = START_TEXT.length * TYPE_MS_PER_CHAR;
  const holdEndsAt = typeDoneAt + HOLD_AFTER_TYPE_MS;
  const startupTotal =
    holdEndsAt + (START_TEXT.length - 1) * FALL_GAP_MS + FALL_DURATION_MS;
  let startupDone = false;

  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.imageSmoothingEnabled = false;

    W = Math.max(20, Math.floor(window.innerWidth / CELL));
    H = Math.max(12, Math.floor(window.innerHeight / CELL));

    drops = new Array(W);
    speed = new Array(W);
    len   = new Array(W);

    for (let x = 0; x < W; x++) {
      drops[x] = (Math.random() * H) | 0;
      speed[x] = SPEED_MIN + ((Math.random() * (SPEED_MAX - SPEED_MIN + 1)) | 0);
      len[x]   = Math.max(TAIL_MIN, ((Math.random() * (H * TAIL_MAX_FRAC)) | 0));
    }

    ceiling = new Array(CEILING_ROWS);
    for (let r = 0; r < CEILING_ROWS; r++) {
      ceiling[r] = new Array(W);
      for (let x = 0; x < W; x++) ceiling[r][x] = randChar();
    }

    frags = [];
    frame = 0;

    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
    ctx.font = `${CELL}px monospace`;
    ctx.textBaseline = "top";
  }

  function addFrag(x, y, ch, v, col) {
    if (frags.length >= FRAG_MAX) return;
    frags.push({ x, y, ch, v, col, life: 1.0 });
  }

  function drawCell(x, y, ch, color) {
    if (x < 0 || x >= W || y < 0 || y >= H) return;
    ctx.fillStyle = color;
    ctx.fillText(ch, x * CELL, y * CELL);
  }

  function drawTextCentered(text, row, color) {
    const startX = Math.max(0, ((W - text.length) / 2) | 0);
    for (let i = 0; i < text.length; i++) {
      drawCell(startX + i, row, text[i], color);
    }
    return startX;
  }

  // fixed timestep loop
  let last = performance.now();
  let acc = 0;

  function loop(now) {
    acc += (now - last);
    last = now;
    while (acc >= FPS_MS) {
      tick(now - t0);
      acc -= FPS_MS;
    }
    requestAnimationFrame(loop);
  }

  function tick(elapsedMs) {
    // fade
    ctx.fillStyle = `rgba(0,0,0,${TRAIL_ALPHA})`;
    ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

    // 1) ceiling crumble (forever)
    for (let x = 0; x < W; x++) {
      if (Math.random() < CRUMBLE_RATE) {
        const r = (Math.random() * CEILING_ROWS) | 0;
        const ch = ceiling[r][x];
        ceiling[r][x] = randChar();
        addFrag(x, r, ch, 0.6 + Math.random() * 1.2, headColor());
      }
    }

    // draw ceiling
    for (let r = 0; r < CEILING_ROWS; r++) {
      const col = (r <= 1) ? "#ffffff" : (r <= 3) ? BODY_GREEN : BODY_DARK;
      for (let x = 0; x < W; x++) drawCell(x, r, ceiling[r][x], col);
    }

    // 2) fragments (forever)
    for (let i = frags.length - 1; i >= 0; i--) {
      const f = frags[i];
      f.y += f.v;
      f.life *= 0.985;
      drawCell(f.x, f.y | 0, f.ch, f.col);
      if (f.y > H + 2 || f.life < 0.08) frags.splice(i, 1);
    }

    // 3) continuous rain: WRAP instead of respawn
    for (let pass = 0; pass < RAIN_PASSES; pass++) {
      for (let x = 0; x < W; x++) {
        if ((frame % speed[x]) !== 0) continue;

        const yHead = drops[x];

        // living tail
        const tailDraw = Math.min(len[x], TAIL_LIVE_CELLS);
        for (let t = 0; t < tailDraw; t += TAIL_SPREAD_STEP) {
          const yy = yHead - t;
          if (yy < CEILING_ROWS || yy >= H) continue;

          let col = BODY_DARK;
          if (t === 0) col = headColor();
          else if (t <= 2) col = BODY_GREEN;
          else if (t <= 7) col = BODY_MID;

          drawCell(x, yy, randChar(), col);
        }

        if (yHead >= CEILING_ROWS && yHead < H && Math.random() < 0.08) {
          drawCell(x, yHead, randChar(), "#ffffff");
        }

        drops[x]++;

        // WRAP: never-ending, no reset pause
        if (drops[x] > H + len[x]) {
          drops[x] = CEILING_ROWS; // back to just under ceiling
          // keep speed/len stable (no "re-roll" feel)
        }
      }
    }

    // 4) Startup plays once, then stops
    if (!startupDone) {
      if (elapsedMs < startupTotal) {
        const wordRow = Math.min(H - 2, CEILING_ROWS + 2);

        const typedCount = Math.min(START_TEXT.length, (elapsedMs / TYPE_MS_PER_CHAR) | 0);
        const typed = START_TEXT.slice(0, typedCount);
        const baseX = drawTextCentered(typed, wordRow, BODY_GREEN);

        if (elapsedMs > holdEndsAt) {
          for (let i = 0; i < START_TEXT.length; i++) {
            const letterStart = holdEndsAt + i * FALL_GAP_MS;
            const t = (elapsedMs - letterStart) / FALL_DURATION_MS;

            if (t >= 0 && t <= 1) {
              const x = baseX + i;
              const useLetter = (Math.random() < 0.60);
              const ch = useLetter ? START_TEXT[i] : randChar();
              addFrag(x, wordRow, ch, 0.9 + Math.random() * 1.7, useLetter ? "#ffffff" : headColor());

              // melt into streams
              if (x >= 0 && x < W) {
                drops[x] = Math.min(drops[x], wordRow + 1);
                speed[x] = Math.min(speed[x], 3);
                len[x] = Math.max(len[x], Math.floor(H * 0.75));
              }
            }
          }
        }
      } else {
        startupDone = true;
      }
    }

    frame++;
  }

  window.addEventListener("resize", resize);
  resize();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
