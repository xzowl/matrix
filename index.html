<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Matrix Terminal — TREVSHADOW</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  // ===== "POWERSHELL LOOK" DIALS =====
  const CELL = 16;              // grid cell size (bigger = chunkier terminal look)
  const FPS_MS = 55;            // higher = slower (like your PS $fpsMs)
  const CEILING_ROWS = 10;      // top layer height
  const CRUMBLE_RATE = 0.020;   // higher = more crumble
  const FRAG_MAX = 1200;

  const RAIN_PASSES = 2;        // 2–3 for denser
  const SPEED_MIN = 2;          // larger = slower columns
  const SPEED_MAX = 8;

  // Trails: PS feels "not smeary". Keep this LOW or 0.
  const TRAIL_ALPHA = 0.10;     // 0 = no trails, 0.06-0.14 = slight trails

  // Startup word
  const START_TEXT = "TREVSHADOW";
  const TYPE_MS_PER_CHAR = 90;
  const HOLD_AFTER_TYPE_MS = 650;
  const FALL_GAP_MS = 140;
  const FALL_DURATION_MS = 1100;

  // “Rainbow” like PS (limited, subtle)
  const HEAD_COLORS = ["#00ff66", "#00ffd5", "#ff4dff", "#ffe14d", "#ffffff"]; // green, cyan, magenta, yellow, white
  const BODY_DARK = "#0b6b2a";
  const BODY_GREEN = "#00ff66";

  const CHARS = (
    "ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜ" +
    "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
    "!@#$%^&*()_+-=[]{};:,.<>/?"
  );

  const randChar = () => CHARS[(Math.random() * CHARS.length) | 0];
  const headColor = () => (Math.random() < 0.70 ? HEAD_COLORS[0] : HEAD_COLORS[(Math.random() * HEAD_COLORS.length) | 0]);

  // Grid size in cells
  let W = 0, H = 0;         // cells
  let pxW = 0, pxH = 0;     // pixels
  let drops = [];           // per column y (cell units)
  let speed = [];           // per column tick divisor
  let len = [];             // per column tail length
  let ceiling = [];         // [row][col] char
  let frags = [];           // falling fragments: {x,y,v, ch, col, life}
  let frame = 0;

  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    pxW = Math.floor(window.innerWidth * dpr);
    pxH = Math.floor(window.innerHeight * dpr);
    canvas.width = pxW;
    canvas.height = pxH;

    // crisp terminal look
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.imageSmoothingEnabled = false;

    W = Math.max(20, Math.floor(window.innerWidth / CELL));
    H = Math.max(12, Math.floor(window.innerHeight / CELL));

    // init rain
    drops = new Array(W);
    speed = new Array(W);
    len   = new Array(W);
    for (let x = 0; x < W; x++) {
      drops[x] = (Math.random() * H) | 0;
      speed[x] = (SPEED_MIN + ((Math.random() * (SPEED_MAX - SPEED_MIN)) | 0));
      len[x] = Math.max(6, ((Math.random() * (H * 0.65)) | 0));
    }

    // init ceiling
    ceiling = new Array(CEILING_ROWS);
    for (let r = 0; r < CEILING_ROWS; r++) {
      ceiling[r] = new Array(W);
      for (let x = 0; x < W; x++) ceiling[r][x] = randChar();
    }

    frags = [];
    frame = 0;

    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

    ctx.font = `${CELL}px monospace`;
    ctx.textBaseline = "top";
  }

  // ===== Startup timing =====
  const t0 = performance.now();
  const typeDoneAt = START_TEXT.length * TYPE_MS_PER_CHAR;
  const holdEndsAt = typeDoneAt + HOLD_AFTER_TYPE_MS;
  const startupTotal =
    holdEndsAt + (START_TEXT.length - 1) * FALL_GAP_MS + FALL_DURATION_MS;

  function addFrag(x, y, ch, v, col) {
    if (frags.length >= FRAG_MAX) return;
    frags.push({ x, y, ch, v, col, life: 1.0 });
  }

  function drawCell(x, y, ch, color) {
    if (x < 0 || x >= W || y < 0 || y >= H) return;
    ctx.fillStyle = color;
    ctx.fillText(ch, x * CELL, y * CELL);
  }

  function drawTextCentered(text, row, color) {
    const startX = Math.max(0, ((W - text.length) / 2) | 0);
    for (let i = 0; i < text.length; i++) {
      drawCell(startX + i, row, text[i], color);
    }
    return startX;
  }

  // Fixed-timestep loop like PS sleep
  let last = performance.now();
  let acc = 0;

  function step(now) {
    acc += (now - last);
    last = now;

    while (acc >= FPS_MS) {
      tick(now - t0);
      acc -= FPS_MS;
    }

    requestAnimationFrame(step);
  }

  function tick(elapsedMs) {
    // Background fade (optional)
    if (TRAIL_ALPHA <= 0) {
      // no trails: hard clear each frame for true terminal feel
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
    } else {
      ctx.fillStyle = `rgba(0,0,0,${TRAIL_ALPHA})`;
      ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
    }

    // 1) Crumble ceiling: pick random cells to fall as fragments
    for (let x = 0; x < W; x++) {
      if (Math.random() < CRUMBLE_RATE) {
        const r = (Math.random() * CEILING_ROWS) | 0;
        const ch = ceiling[r][x];
        ceiling[r][x] = randChar();
        addFrag(x, r, ch, 0.6 + Math.random() * 1.2, headColor());
      }
    }

    // Draw ceiling rows (solid, layered)
    for (let r = 0; r < CEILING_ROWS; r++) {
      const col = (r <= 1) ? "#ffffff" : (r <= 3) ? BODY_GREEN : BODY_DARK;
      for (let x = 0; x < W; x++) {
        drawCell(x, r, ceiling[r][x], col);
      }
    }

    // 2) Update + draw fragments
    for (let i = frags.length - 1; i >= 0; i--) {
      const f = frags[i];
      f.y += f.v;
      f.life *= 0.985;

      // draw
      drawCell(f.x, f.y | 0, f.ch, f.col);

      if (f.y > H + 2 || f.life < 0.08) frags.splice(i, 1);
    }

    // 3) Rain (dense)
    for (let pass = 0; pass < RAIN_PASSES; pass++) {
      for (let x = 0; x < W; x++) {
        if ((frame % speed[x]) !== 0) continue;

        const yHead = drops[x];
        const yBody = yHead - 2;

        if (yBody >= CEILING_ROWS) {
          drawCell(x, yBody, randChar(), BODY_DARK);
        }
        if (yHead >= CEILING_ROWS) {
          drawCell(x, yHead, randChar(), headColor());
          if (Math.random() < 0.08) drawCell(x, yHead, randChar(), "#ffffff"); // sparkle
        }

        drops[x]++;

        if (drops[x] > H + len[x] && Math.random() < 0.08) {
          drops[x] = CEILING_ROWS;
          speed[x] = SPEED_MIN + ((Math.random() * (SPEED_MAX - SPEED_MIN)) | 0);
          len[x] = Math.max(6, ((Math.random() * (H * 0.70)) | 0));
        }
      }
    }

    // 4) Startup: type + fallaway one letter at a time (spawning fragments)
    if (elapsedMs < startupTotal) {
      const wordRow = Math.min(H - 2, CEILING_ROWS + 2);

      // typing
      const typedCount = Math.min(START_TEXT.length, (elapsedMs / TYPE_MS_PER_CHAR) | 0);
      const typed = START_TEXT.slice(0, typedCount);
      const baseX = drawTextCentered(typed, wordRow, BODY_GREEN);

      // after hold: letters fall away sequentially (and spawn fragments)
      if (elapsedMs > holdEndsAt) {
        for (let i = 0; i < START_TEXT.length; i++) {
          const letterStart = holdEndsAt + i * FALL_GAP_MS;
          const t = (elapsedMs - letterStart) / FALL_DURATION_MS;

          if (t >= 0 && t <= 1) {
            const x = baseX + i;
            // spawn falling chunk
            const useLetter = (Math.random() < 0.55);
            const ch = useLetter ? START_TEXT[i] : randChar();
            addFrag(x, wordRow, ch, 0.9 + Math.random() * 1.7, useLetter ? "#ffffff" : headColor());

            // also seed rain under it so it “melts” into the streams
            if (x >= 0 && x < W) {
              drops[x] = Math.min(drops[x], wordRow + 1);
              speed[x] = Math.min(speed[x], 4);
            }
          }
        }
      }
    }

    frame++;
  }

  window.addEventListener("resize", resize);
  resize();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
