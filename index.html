<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Matrix Terminal — TREVSHADOW</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  // ===== LOOK / SPEED =====
  const CELL = 16;
  const FPS_MS = 88;

  // Ceiling
  const CEILING_ROWS = 3;
  const TRANSITION_ROWS = 7;
  const CRUMBLE_RATE = 0.020;

  // Rain (LESS OVERLAP)
  const RAIN_PASSES = 1;           // was 3 — huge overlap killer
  const SPEED_MIN = 1;
  const SPEED_MAX = 3;

  // Faster decay (LESS TRAIL / LINGER)
  const TRAIL_ALPHA = 0.10;        // was 0.05 — old letters die faster

  // Living tail (shorter, more variety)
  const TAIL_LIVE_CELLS = 18;      // was 26 — less stacking
  const TAIL_SPREAD_STEP = 1;

  // Startup text
  const START_TEXT = "TREVSHADOW";
  const TYPE_MS_PER_CHAR = 90;
  const HOLD_AFTER_TYPE_MS = 650;
  const FALL_GAP_MS = 140;
  const FALL_DURATION_MS = 1100;

  // Slow top + bottom fade
  const SLOW_TOP_FRAC = 0.33;
  const TOP_MULT = 0.18;
  const MID_MULT = 0.52;
  const BOTTOM_FADE_FRAC = 0.10;

  // Readable code whispers (cell-by-cell)
  const CODE_WHISPER_RATE = 0.06;
  const CODE_WHISPER_ALPHA = 0.16;
  const CODE_WHISPER_ROWS = 14;

  // Rare >.< stamps
  const EMOTE_RATE = 0.006;

  // Colors
  const BODY_DARK  = "#0b6b2a";
  const BODY_MID   = "#00b84a";
  const BODY_GREEN = "#00ff66";
  const HEAD_COLORS = ["#00ff66", "#00ffd5", "#ff4dff", "#ffe14d", "#ffffff"];

  const MATRIX_CHARS = (
    "ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜ" +
    "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
    "!@#$%^&*()_+-=[]{};:,.<>/?"
  );

  const CODE_TOKENS = [
    "const","function","return","tick()","resize()",
    "speedMultiplierForY","bottomFadeAlpha",
    "Math.random()","requestAnimationFrame",
    "ctx.fillRect","canvas","CELL","FPS_MS",
    "TREVSHADOW",">.<"
  ];

  const CODE_TEXT = `
const CELL=16,FPS_MS=88;
function tick(){ return; }
function speedMultiplierForY(y){ return y; }
function bottomFadeAlpha(y){ return y; }
// TREVSHADOW >.<
`;
  const CODE_GLYPHS = Array.from(new Set(
    CODE_TEXT.replace(/\s+/g," ").split("").filter(ch => ch !== "\n" && ch !== "\r")
  )).join("");

  const randFrom = (s) => s[(Math.random() * s.length) | 0];
  const randChar = () => randFrom(MATRIX_CHARS);

  // More variety, less pattern lock: salt per column affects glyph selection
  function randGlyphSalted(x) {
    // ~22% code glyphs, but with column salt
    if (Math.random() < 0.22) return CODE_GLYPHS[(x + ((Math.random()*CODE_GLYPHS.length)|0)) % CODE_GLYPHS.length];
    return MATRIX_CHARS[(x + ((Math.random()*MATRIX_CHARS.length)|0)) % MATRIX_CHARS.length];
  }

  const headColor = () => (Math.random() < 0.70 ? HEAD_COLORS[0] : HEAD_COLORS[(Math.random() * HEAD_COLORS.length) | 0]);
  const randToken = () => CODE_TOKENS[(Math.random() * CODE_TOKENS.length) | 0];

  // Grid size
  let W = 0, H = 0, dpr = 1, cssW = 0, cssH = 0;

  // State
  let drops = [], speed = [], dropAcc = [], ceiling = [];
  let frame = 0;

  // Startup timing (once)
  const t0 = performance.now();
  const typeDoneAt = START_TEXT.length * TYPE_MS_PER_CHAR;
  const holdEndsAt = typeDoneAt + HOLD_AFTER_TYPE_MS;
  const startupTotal = holdEndsAt + (START_TEXT.length - 1) * FALL_GAP_MS + FALL_DURATION_MS;
  let startupDone = false;

  function resize() {
    dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);

    cssW = canvas.width / dpr;
    cssH = canvas.height / dpr;

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.imageSmoothingEnabled = false;

    W = Math.max(20, Math.floor(cssW / CELL));
    H = Math.max(12, Math.floor(cssH / CELL));

    drops = new Array(W);
    speed = new Array(W);
    dropAcc = new Array(W);

    for (let x=0; x<W; x++) {
      drops[x] = (Math.random() * H) | 0;
      speed[x] = SPEED_MIN + ((Math.random() * (SPEED_MAX - SPEED_MIN + 1)) | 0);
      dropAcc[x] = 0;
    }

    ceiling = new Array(CEILING_ROWS);
    for (let r=0; r<CEILING_ROWS; r++) {
      ceiling[r] = new Array(W);
      for (let x=0; x<W; x++) ceiling[r][x] = randGlyphSalted(x);
    }

    frame = 0;

    ctx.font = `${CELL}px monospace`;
    ctx.textBaseline = "top";
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, cssW, cssH);
  }

  function drawCell(x, y, ch, color, alpha=1) {
    if (x<0 || x>=W || y<0 || y>=H) return;
    if (alpha<=0) return;
    const prev = ctx.globalAlpha;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    ctx.fillText(ch, x*CELL, y*CELL);
    ctx.globalAlpha = prev;
  }

  function drawTextCentered(text, row, color) {
    const startX = Math.max(0, ((W - text.length) / 2) | 0);
    for (let i=0; i<text.length; i++) drawCell(startX+i, row, text[i], color, 1);
    return startX;
  }

  function ceilingAlphaForRow(r) {
    const startFade = Math.max(0, CEILING_ROWS - TRANSITION_ROWS);
    if (r < startFade) return 1;
    const t = (CEILING_ROWS - r) / Math.max(1, TRANSITION_ROWS);
    return Math.max(0.10, Math.min(1, t));
  }

  function rainAlphaForY(y) {
    if (y >= CEILING_ROWS) return 1;
    const t = (y + 1) / Math.max(1, TRANSITION_ROWS);
    return Math.max(0.0, Math.min(0.85, t));
  }

  function speedMultiplierForY(y) {
    const p = y / Math.max(1, (H - 1));
    if (p <= SLOW_TOP_FRAC) return TOP_MULT;
    const t = (p - SLOW_TOP_FRAC) / Math.max(0.0001, (1 - SLOW_TOP_FRAC));
    const eased = t * t;
    return TOP_MULT + (MID_MULT - TOP_MULT) * eased;
  }

  function bottomFadeAlpha(y) {
    const p = y / Math.max(1, (H - 1));
    const start = 1.0 - BOTTOM_FADE_FRAC;
    if (p <= start) return 1;
    const t = (p - start) / Math.max(0.0001, BOTTOM_FADE_FRAC);
    return Math.max(0, 1 - t);
  }

  function stampEmote() {
    const y = (Math.random() * Math.min(H - 2, Math.max(6, Math.floor(H * 0.60)))) | 0;
    const x = (Math.random() * (W - 3)) | 0;
    const a = 0.45 * bottomFadeAlpha(y);
    drawCell(x + 0, y, ">", "#ffffff", a);
    drawCell(x + 1, y, ".", "#ff4dff", a);
    drawCell(x + 2, y, "<", "#ffffff", a);
  }

  function codeWhisper() {
    if (Math.random() > CODE_WHISPER_RATE) return;
    const token = randToken();
    const y = (Math.random() * Math.min(H - 1, CODE_WHISPER_ROWS)) | 0;
    let x = (Math.random() * Math.max(1, W - token.length - 2)) | 0;
    const slope = (Math.random() < 0.7) ? 0 : (Math.random() < 0.5 ? 1 : -1);

    for (let i=0; i<token.length; i++) {
      if (Math.random() < 0.22) { x++; continue; } // gaps = less blocky
      const yy = y + (slope ? (slope * ((i / 4) | 0)) : 0);
      const a = CODE_WHISPER_ALPHA * bottomFadeAlpha(yy) * (yy < CEILING_ROWS ? ceilingAlphaForRow(yy|0) : 1);
      drawCell(x, yy, token[i], BODY_DARK, a);
      x++;
      if (x >= W) break;
    }
  }

  // Safe fixed-step loop
  let last = performance.now();
  let accTime = 0;
  const MAX_TICKS_PER_FRAME = 6;

  function loop(now) {
    const dt = now - last;
    last = now;
    accTime += Math.min(dt, 200);

    let ticks = 0;
    while (accTime >= FPS_MS && ticks < MAX_TICKS_PER_FRAME) {
      tick(now - t0);
      accTime -= FPS_MS;
      ticks++;
    }
    if (ticks >= MAX_TICKS_PER_FRAME) accTime = 0;

    requestAnimationFrame(loop);
  }

  function tick(elapsedMs) {
    // faster fade = less lingering
    ctx.fillStyle = `rgba(0,0,0,${TRAIL_ALPHA})`;
    ctx.fillRect(0, 0, cssW, cssH);

    codeWhisper();
    if (Math.random() < EMOTE_RATE) stampEmote();

    // ceiling lightly changes (no heavy redraw noise)
    for (let x=0; x<W; x++) {
      if (Math.random() < CRUMBLE_RATE) {
        const r = (Math.random() * CEILING_ROWS) | 0;
        ceiling[r][x] = randGlyphSalted(x);
      }
    }

    for (let r=0; r<CEILING_ROWS; r++) {
      const a = ceilingAlphaForRow(r);
      const col = (r <= 1) ? "#ffffff" : (r <= 2) ? BODY_GREEN : BODY_DARK;
      for (let x=0; x<W; x++) drawCell(x, r, ceiling[r][x], col, a);
    }

    // Rain (single pass, shorter tail, more change)
    for (let x=0; x<W; x++) {
      if ((frame % speed[x]) !== 0) continue;

      const yHead = drops[x];
      for (let t=0; t<TAIL_LIVE_CELLS; t+=TAIL_SPREAD_STEP) {
        const yy = yHead - t;
        if (yy < 0 || yy >= H) continue;

        let col = BODY_DARK;
        if (t === 0) col = headColor();
        else if (t <= 2) col = BODY_GREEN;
        else if (t <= 7) col = BODY_MID;

        const a = rainAlphaForY(yy) * bottomFadeAlpha(yy);
        // change always: new glyph every draw
        drawCell(x, yy, randGlyphSalted(x), col, a);
      }

      // sparkle
      if (yHead >= 0 && yHead < H && Math.random() < 0.07) {
        const a = rainAlphaForY(yHead) * bottomFadeAlpha(yHead);
        drawCell(x, yHead, randGlyphSalted(x), "#ffffff", a);
      }

      // motion
      dropAcc[x] += speedMultiplierForY(yHead);
      if (dropAcc[x] >= 1) {
        const steps = Math.min(2, dropAcc[x] | 0); // cap jumps
        drops[x] += steps;
        dropAcc[x] -= steps;
      }

      if (drops[x] > H + TAIL_LIVE_CELLS) {
        drops[x] = 0;
        dropAcc[x] = 0;
      }
    }

    // Startup: TREVSHADOW types and falls away (no fragments now = less layering)
    if (!startupDone) {
      if (elapsedMs < startupTotal) {
        const wordRow = Math.min(H - 2, CEILING_ROWS + 2);
        const typedCount = Math.min(START_TEXT.length, (elapsedMs / TYPE_MS_PER_CHAR) | 0);
        const typed = START_TEXT.slice(0, typedCount);
        const baseX = drawTextCentered(typed, wordRow, BODY_GREEN);

        if (elapsedMs > holdEndsAt) {
          for (let i=0; i<START_TEXT.length; i++) {
            const letterStart = holdEndsAt + i * FALL_GAP_MS;
            const t = (elapsedMs - letterStart) / FALL_DURATION_MS;
            if (t >= 0 && t <= 1) {
              const xx = baseX + i;
              // quickly “falls away” by injecting stronger decay under letters
              if (xx >= 0 && xx < W) drops[xx] = Math.min(drops[xx], wordRow + 1);
            }
          }
        }
      } else {
        startupDone = true;
      }
    }

    frame++;
  }

  addEventListener("resize", resize);
  resize();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
