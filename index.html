<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Matrix — TREVSHADOW</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; }
    #err{
      position:fixed; inset:0; padding:16px;
      font:14px/1.4 monospace; color:#fff; background:#000;
      white-space:pre-wrap; display:none;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="err"></div>

<script>
(() => {
  const errBox = document.getElementById("err");
  const showErr = (e) => {
    errBox.style.display = "block";
    errBox.textContent = "Matrix crashed:\n\n" + (e && e.stack ? e.stack : String(e));
  };

  try {
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha:false });

    // =========================
    // FINAL LOCKED DIALS
    // =========================
    const FONT_SIZE = 14;            // smaller = more letters
    const FADE = 0.10;               // clean trails, prevents blocky buildup
    const BASE_SPEED = 0.11;         // overall speed
    const SPEED_JITTER = 0.17;       // per-column variation
    const DENSITY_PASSES = 1;        // keep crisp (no rectangle stacking)

    // NEW: Organic + depth (the only additions)
    const JITTER_PX = 0.35;          // subtle horizontal drift (keep < 0.6)
    const DEPTH_MIN_ALPHA = 0.55;    // background opacity
    const DEPTH_MAX_ALPHA = 1.00;    // foreground opacity

    // Heads: rainbow + sparkle (kept)
    const RAINBOW_HEAD_CHANCE = 0.75;
    const SPARKLE_CHANCE = 0.04;

    // Ceiling crumble layers (kept)
    const CEILING_ROWS = 11;
    const CRUMBLE_RATE = 0.020;
    const CRUMBLE_FALL_SPEED = 1.35;

    // Startup word (kept)
    const START_TEXT = "TREVSHADOW";
    const TYPE_MS_PER_CHAR = 85;
    const HOLD_AFTER_TYPE_MS = 600;
    const DISSOLVE_MS = 1300;

    const BODY_GREEN = "#00ff66";
    const HEAD_MINT  = "#7CFFB6";

    const CHARS =
      "アイウエオカキクケコサシスセソタチツテトナニヌネノ" +
      "ハヒフヘホマミムメモヤユヨラリルレロワ" +
      "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
      "!@#$%^&*()_+-=[]{};:,.<>/?";

    const randChar = () => CHARS[(Math.random()*CHARS.length)|0];

    let columns = 0, drops = [], speeds = [];
    let hueBase = 0;

    // Ceiling grid + falling fragments
    let ceilGrid = []; // [row][col]
    let frags = [];    // falling crumbs

    function setup() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);

      canvas.width  = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // keep text crisp
      ctx.imageSmoothingEnabled = false;

      columns = Math.max(1, Math.floor(window.innerWidth / FONT_SIZE));

      drops  = new Array(columns);
      speeds = new Array(columns);

      for (let i=0; i<columns; i++) {
        drops[i] = Math.random() * (window.innerHeight / FONT_SIZE);
        speeds[i] = BASE_SPEED + Math.random() * SPEED_JITTER;
      }

      // Build ceiling layer
      ceilGrid = new Array(CEILING_ROWS);
      for (let r=0; r<CEILING_ROWS; r++) {
        ceilGrid[r] = new Array(columns);
        for (let c=0; c<columns; c++) ceilGrid[r][c] = randChar();
      }

      frags = [];

      ctx.font = `${FONT_SIZE}px monospace`;
      ctx.textBaseline = "top";
      ctx.textAlign = "left";

      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,window.innerWidth,window.innerHeight);
    }

    function headColor(i, y) {
      if (Math.random() < SPARKLE_CHANCE) return "#fff";
      if (Math.random() < RAINBOW_HEAD_CHANCE) {
        const hue = (hueBase + i*15 + y*0.12) % 360;
        return `hsl(${hue},95%,65%)`;
      }
      return HEAD_MINT;
    }

    // Crumble ceiling into falling fragments
    function updateCrumble() {
      for (let c=0; c<columns; c++) {
        if (Math.random() < CRUMBLE_RATE) {
          const r = (Math.random() * CEILING_ROWS) | 0;
          const ch = ceilGrid[r][c];
          ceilGrid[r][c] = randChar();

          frags.push({
            x: c * FONT_SIZE,
            y: r * FONT_SIZE,
            ch,
            vy: (BASE_SPEED + Math.random()*0.8) * FONT_SIZE * CRUMBLE_FALL_SPEED,
            life: 1.0
          });
        }
      }

      const H = window.innerHeight;
      for (let i=frags.length-1; i>=0; i--) {
        const f = frags[i];
        f.y += f.vy;
        f.life *= 0.988;
        if (f.y > H + 60 || f.life < 0.08) frags.splice(i, 1);
      }
    }

    function drawCeiling() {
      // Ceiling block
      for (let r=0; r<CEILING_ROWS; r++) {
        for (let c=0; c<columns; c++) {
          const x = c * FONT_SIZE;
          const y = r * FONT_SIZE;

          // slightly varied brightness by row
          const rowMix = 1 - (r / (CEILING_ROWS + 2));
          ctx.globalAlpha = 0.55 + rowMix * 0.35;

          ctx.fillStyle = rowMix > 0.7 ? HEAD_MINT : BODY_GREEN;
          ctx.fillText(ceilGrid[r][c], x, y);
        }
      }

      // Falling fragments
      for (const f of frags) {
        ctx.globalAlpha = Math.min(1, f.life);
        ctx.fillStyle = headColor((f.x / FONT_SIZE) | 0, f.y);
        ctx.fillText(f.ch, f.x, f.y);
      }

      ctx.globalAlpha = 1;
    }

    // Startup word typed then dissolves into fragments
    const t0 = performance.now();

    function drawStartup(elapsed) {
      const typedCount = Math.min(
        START_TEXT.length,
        Math.floor(elapsed / TYPE_MS_PER_CHAR)
      );
      const typed = START_TEXT.slice(0, typedCount);

      const typeDoneAt = START_TEXT.length * TYPE_MS_PER_CHAR;
      const holdEndsAt = typeDoneAt + HOLD_AFTER_TYPE_MS;
      const dissolveEndsAt = holdEndsAt + DISSOLVE_MS;

      const cx = window.innerWidth / 2;
      const cy = Math.max(CEILING_ROWS * FONT_SIZE + 70, window.innerHeight * 0.30);

      const size = Math.max(34, Math.min(92, Math.floor(window.innerWidth / 10)));

      ctx.save();
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = `900 ${size}px monospace`;

      // base glow
      ctx.globalAlpha = 0.32;
      ctx.fillStyle = BODY_GREEN;
      ctx.fillText(typed, cx, cy);

      // bright stroke
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = "#caffde";
      ctx.fillText(typed, cx, cy);

      // dissolve into falling crumbs
      if (elapsed > holdEndsAt && elapsed < dissolveEndsAt) {
        const t = (elapsed - holdEndsAt) / DISSOLVE_MS;
        const alpha = 1 - t;

        ctx.globalAlpha = alpha;

        const wordWidth = ctx.measureText(START_TEXT).width;
        const left = cx - wordWidth/2;

        // spawn crumbs from the word area
        for (let k=0; k<10; k++) {
          const rx = left + Math.random() * wordWidth;
          const col = Math.max(0, Math.min(columns-1, Math.floor(rx / FONT_SIZE)));

          frags.push({
            x: col * FONT_SIZE,
            y: cy - size * 0.25 + Math.random() * (size * 0.5),
            ch: (Math.random() < 0.55)
              ? START_TEXT[(Math.random()*START_TEXT.length)|0]
              : randChar(),
            vy: (BASE_SPEED + Math.random()*1.0) * FONT_SIZE * 1.7,
            life: 1.0
          });
        }
      }

      ctx.restore();

      return elapsed < dissolveEndsAt;
    }

    // FINAL: Rain with ONLY the two requested upgrades:
    // (1) subtle jitter (2) depth fade
    function drawRain() {
      for (let pass=0; pass<DENSITY_PASSES; pass++) {
        for (let i=0; i<columns; i++) {
          const x = i * FONT_SIZE;
          const y = drops[i] * FONT_SIZE;

          // (2) depth fade: farther letters dimmer, nearer brighter
          const depth = Math.min(1, Math.max(0, y / window.innerHeight));
          ctx.globalAlpha = DEPTH_MIN_ALPHA + depth * (DEPTH_MAX_ALPHA - DEPTH_MIN_ALPHA);

          // (1) subtle organic drift
          const jitter = (Math.random() - 0.5) * JITTER_PX;

          // body
          ctx.fillStyle = BODY_GREEN;
          ctx.fillText(randChar(), x + jitter, y);

          // head highlight
          const headY = y - FONT_SIZE * 2;
          if (headY >= 0 && headY < window.innerHeight) {
            ctx.fillStyle = headColor(i, headY);
            ctx.fillText(randChar(), x + jitter, headY);
          }

          drops[i] += speeds[i];

          if (y > window.innerHeight && Math.random() > 0.975) {
            drops[i] = 0;
            speeds[i] = BASE_SPEED + Math.random() * SPEED_JITTER;
          }
        }
      }

      // IMPORTANT: reset alpha so ceiling/startup stay crisp & consistent
      ctx.globalAlpha = 1;
    }

    function frame(t) {
      const elapsed = t - t0;
      hueBase = (hueBase + 1) % 360;

      // clean fade layer (prevents block buildup)
      ctx.fillStyle = `rgba(0,0,0,${FADE})`;
      ctx.fillRect(0,0,window.innerWidth,window.innerHeight);

      // ceiling + crumble
      updateCrumble();
      drawCeiling();

      // rain
      drawRain();

      // startup
      drawStartup(elapsed);

      requestAnimationFrame(frame);
    }

    window.addEventListener("resize", setup);
    window.addEventListener("error", (ev) => showErr(ev.error || ev.message));

    setup();
    requestAnimationFrame(frame);

  } catch (e) {
    showErr(e);
  }
})();
</script>
</body>
</html>
